<!doctype html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data Visuals</title>
    <script src="https://cdn.zingchart.com/zingchart.min.js"></script>
</head>

<body>
    <!-- ZingChart -->
    <style>
        #charts {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(1fr));
            gap: 20px;
            padding: 20px;
        }

        #charts>div {
            background: #fff;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
            padding: 10px;
        }
    </style>

    <p style="font-size: xx-large; display: flex; justify-content: center;">Try clicking on things!</p>

    <div id="charts">
        <div id="bar3"></div>
        <div id="bar2"></div>
        <div id="pie"></div>
        <div id="cookies"></div>
        <div id="javascript"></div>
        <div id="network"></div>
        <div id="languages"></div>
    </div>
    <script type="module">
        // Retrieves getData function, which requests columns from a table of the web_analytics DB
        import { getData } from '/fetch.js';

        ZC.LICENSE = ["569d52cefae586f634c54f86dc99e6a9", "b55b025e438fa8a98e32482b5f768ff5"];

        async function renderCharts() {
            try {
                // Dynamic fetch of data
                const rawStaticData = await getData('static',
                    ['userScreenWidth', 'userScreenHeight', 'userWindowWidth', 'userWindowHeight', 'userLang',
                        'userNetConnType', 'acceptsCookies', 'allowsJavaScript']);

                console.log("Fetched static data:", rawStaticData);

                // Aggregate counts
                const pieCounts = {};

                const bar1280Counts2 = {}; // window height counts where window width is 1280
                const bar500Counts2 = {}; // window height counts where window width is 500

                const bar1280Counts3 = {}; // screen height counts where screen width is 1280
                const bar1920Counts3 = {}; // screen height counts where screen width is 500
                const barOtherCounts3 = {}; // screen height counts where screen width is not 1280 or 500

                rawStaticData.forEach(item => {
                    // Pie chart labels and values
                    parseCounts('pie', item.userScreenWidth, pieCounts);

                    // 2 series bar chart
                    // Comparing screen widths in terms of corresponding screen height counts
                    parseCounts('bar2', [item.userWindowWidth, item.userWindowHeight], [bar1280Counts2, bar500Counts2], ['1280', '500']);

                    // 3 series bar chart
                    // Comparing 3 groups of user screen width in terms of their screen height
                    parseCounts('bar3', [item.userScreenWidth, item.userScreenHeight], [bar1280Counts3, bar1920Counts3, barOtherCounts3], ['1280', '1920', 'other']);

                    // NOTE: Currently with the way 3 series bar charts are hard coded, other values are grouped together, might have to change this
                    // functionaliy to be more flexible with a different kind of bar3 configuration/style, but with the current one it works.
                });


                // Convert to arrays
                const pieLabels = Object.keys(pieCounts);
                const pieValues = Object.values(pieCounts);

                const barLabels2 = Object.keys(bar1280Counts2); // either 1280 or 500 would work here
                // Ensure values are arrays and match the order of barLabels2
                const bar1280Values2 = barLabels2.map(h => bar1280Counts2[h] || 0);
                const bar500Values2 = barLabels2.map(h => bar500Counts2[h] || 0);

                const barLabels3 = Object.keys(barOtherCounts3); // any of the three would work here
                // Ensure values are arrays and match the order of barLabels3
                const bar1280Values3 = barLabels3.map(h => bar1280Counts3[h] || 0);
                const bar1920Values3 = barLabels3.map(h => bar1920Counts3[h] || 0);
                const barOtherValues3 = barLabels3.map(h => barOtherCounts3[h] || 0);

                // --- 3-Series Bar Chart ---
                const screenDimensions3 = generateBar3Config([bar1280Values3, bar1920Values3, barOtherValues3],
                    "Screen Dimensions", barLabels3, "Count", ["Screen Width: 1280", "Screen Width: 1920", "Screen Width: Other"],
                    ['pink', 'purple', 'blue'], { alpha: [0.7, 0.7, 0.7] }
                );

                // -- 2-Series Bar Chart --
                const windowDimensions2 = generateBar2Config([bar500Values2, bar1280Values2],
                    "Window Dimensions", barLabels2, "Count", ["Window Width: 500", "Window Width: 1280"],
                    ["#3366FF", "#00BFFF"], { alpha: [1, 0.7] }
                );

                // -- Pie Chart --
                const pieChart = generatePieConfig(pieLabels, pieValues, "Screen Width Distribution", {
                    threshold: "15%",
                    others: { text: "Others", backgroundColor: "#999 #333" },
                    slice: 0.6
                });

                // Render
                zingchart.render({ id: 'bar3', data: JSON.stringify(screenDimensions3), height: 1000, width: '100%' });
                zingchart.render({ id: 'bar2', data: JSON.stringify(windowDimensions2), height: 1000, width: '100%' });
                zingchart.render({ id: 'pie', data: JSON.stringify(pieChart), height: 1000, width: '100%' });

                // Aggregate counts
                const cookieCounts = {};
                rawStaticData.forEach(item => {
                    cookieCounts[item.acceptsCookies === "1" ? "Accepts" : "Rejects"] =
                        (cookieCounts[item.acceptsCookies === "1" ? "Accepts" : "Rejects"] || 0) + 1;
                });

                // Convert
                const cookieLabels = Object.keys(cookieCounts);
                const cookieValues = Object.values(cookieCounts);

                // Config
                const cookieChart = {
                    type: "pie",
                    title: { text: "Cookie Acceptance" },
                    plot: {
                        slice: '60%',
                        detach: false,
                        valueBox: { placement: 'in', text: '%t\n%npv%' }
                    },
                    series: cookieLabels.map((label, i) => ({
                        text: label,
                        values: [cookieValues[i]]
                    }))
                };

                // Render
                zingchart.render({ id: "cookies", data: cookieChart, height: 1000, width: '100%' });

                const netCounts = {};
                rawStaticData.forEach(item => {
                    netCounts[item.userNetConnType || "Unknown"] =
                        (netCounts[item.userNetConnType || "Unknown"] || 0) + 1;
                });

                const netLabels = Object.keys(netCounts);
                const netValues = Object.values(netCounts);

                const netChart = {
                    type: "bar",
                    title: { text: "Network Connection Types" },
                    scaleX: { values: netLabels },
                    series: [{ values: netValues, backgroundColor: "#33ccff" }]
                };

                zingchart.render({ id: "network", data: netChart, height: 1000, width: '100%' });

                const jsCounts = {};
                rawStaticData.forEach(item => {
                    jsCounts[item.allowsJavaScript === "1" ? "Enabled" : "Disabled"] =
                        (jsCounts[item.allowsJavaScript === "1" ? "Enabled" : "Disabled"] || 0) + 1;
                });

                const jsLabels = Object.keys(jsCounts);
                const jsValues = Object.values(jsCounts);

                const jsChart = {
                    type: "pie",
                    title: { text: "JavaScript Support" },
                    plot: { slice: '55%' },
                    series: jsLabels.map((label, i) => ({
                        text: label,
                        values: [jsValues[i]]
                    }))
                };

                zingchart.render({ id: "javascript", data: jsChart, height: 1000, width: '100%' });

                const langCounts = {};
                rawStaticData.forEach(item => {
                    langCounts[item.userLang || "Unknown"] =
                        (langCounts[item.userLang || "Unknown"] || 0) + 1;
                });

                const langLabels = Object.keys(langCounts);
                const langValues = Object.values(langCounts);

                const langChart = {
                    type: "bar",
                    title: { text: "User Languages" },
                    scaleX: {
                        values: langLabels,
                        item: {
                            angle: -45,    // rotate labels if needed
                            'font-size': 10
                        },
                        guide: { visible: false },
                        tick: { visible: true },
                        step: 1,          // show every label
                        'max-items': langLabels.length, // prevent auto-skipping
                        'items-overlap': true // allow overlap if needed
                    },
                    series: [
                        { values: langValues, backgroundColor: "#ff9933" }
                    ]
                };

                zingchart.render({ id: "languages", data: langChart, height: 1000, width: '100%' });

            } catch (err) {
                console.error("Error rendering charts:", err);
            }
        }

        /**
         * A function to parse raw data from our API and populate any
         * given count object.
         * @param {string} chartType - Type of chart ('pie', 'bar2', 'bar3')
         * @param {any} rawData - Raw data to be parsed
         * @param {Object} countObj - Object to store counts
         */
        function parseCounts(chartType, rawData, countObj, valueChecks = []) {
            switch (chartType) {
                case 'pie':
                    try {
                        countObj[rawData] = (countObj[rawData] || 0) + 1;
                    } catch (err) {
                        console.error("Error parsing pie chart data:", err);
                    }
                    break;
                case 'bar2':

                    // raw data item will be like this: userWindowWidth = 1280, userWindowHeight = 720

                    try {
                        // rawData, countObj, and valueChecks are expected to be an array of two elements
                        const [x, y] = rawData;
                        const [countObj1, countObj2] = countObj;
                        const [valCheck1, valCheck2] = valueChecks;
                        switch (String(x)) {
                            case String(valCheck1):
                                countObj1[y] = (countObj1[y] || 0) + 1;
                                countObj2[y] = countObj2[y] || 0;
                                break;
                            case String(valCheck2):
                                countObj1[y] = countObj1[y] || 0;
                                countObj2[y] = (countObj2[y] || 0) + 1;
                                break;
                            default:
                                return; // Ignore other values
                        }
                    } catch (err) {
                        console.error("Error parsing 2-series bar chart data:", err);
                    }
                    break;
                case 'bar3':
                    try {
                        // rawData, countObj, and valueChecks are expected to be an array of two elements
                        const [x, y] = rawData;
                        const [countObj1, countObj2, countObj3] = countObj;
                        const [valCheck1, valCheck2, valCheck3] = valueChecks;
                        switch (x) {
                            case valCheck1:
                                countObj1[y] = (countObj1[y] || 0) + 1;
                                countObj2[y] = countObj2[y] || 0;
                                countObj3[y] = countObj3[y] || 0;
                                break;
                            case valCheck2:
                                countObj1[y] = countObj1[y] || 0;
                                countObj2[y] = (countObj2[y] || 0) + 1;
                                countObj3[y] = countObj3[y] || 0;
                                break;
                            default:
                                countObj1[y] = countObj1[y] || 0;
                                countObj2[y] = countObj2[y] || 0;
                                countObj3[y] = (countObj3[y] || 0) + 1;
                                return;
                        }
                    } catch (err) {
                        console.error("Error parsing 3-series bar chart data:", err);
                    }
                    break;
                default:
                    console.error("Unknown chart type:", chartType);
            }
        }

        /**
         * Generates configuration for a 3-series bar chart.
         * @param {Array} values - Array of arrays containing values for each series.
         * @param {string} title - Title of the chart.
         * @param {Array} x_axis - Labels for the x-axis.
         * @param {string} y_axis - Label for the y-axis.
         * @param {Array} legend_labels - Labels for the legend.
         * @param {Array} colors - Colors for each series.
         * @param {Object} options - Additional options like alpha values for each series.
         * @returns {Object} - Configuration object for the 3-series bar chart.
         */
        function generateBar3Config(values, title, x_axis, y_axis, legend_labels, colors, options) {
            return {
                type: 'bar',
                title: {
                    text: title,
                    backgroundColor: 'none',
                    fontSize: "22px",
                    alpha: 0.8,
                    adjustLayout: true
                },
                plotarea: { margin: 'dynamic' },
                scaleX: {
                    values: x_axis,
                    zooming: true,
                    item: {
                        fontSize: 10
                    },
                    label: { text: "Screen Height", fontFamily: "Helvetica", bold: true, fontSize: "12px", fontColor: "#7E7E7E" }
                },
                scaleY: {
                    lineColor: '#7E7E7E',
                    item: { fontColor: '#7e7e7e' },
                    guide: { visible: true },
                    label: { text: "Count", fontFamily: "Helvetica", bold: true, fontSize: "12px", fontColor: "#7E7E7E" },
                },
                legend: {
                    layout: 'x3',
                    align: 'center',
                    adjustLayout: true,
                    shadow: false,
                    overflow: 'page',
                    alpha: 0.05,
                    marker: { type: 'rectangle', borderColor: 'none', size: 12 },
                    borderWidth: 0,
                    maxItems: 3,
                    toggleAction: 'hide',
                    pageOn: { backgroundColor: '#000', size: 10, alpha: 0.75 },
                    pageOff: { backgroundColor: '#7E7E7E', size: 10, alpha: 0.75 },
                    pageStatus: { color: 'black' }
                },
                plot: { 'bars-space-left': 0.15, 'bars-space-right': 0.15 },
                series: legend_labels.map((label, i) => ({
                    text: label,
                    values: values[i],
                    backgroundColor: colors[i],
                    alpha: options?.alpha[i] || 1
                }))
            }
        }

        /**
         * Generates configuration for a 2-series bar chart.
         * @param {Array} values - Array of arrays containing values for each series.
         * @param {string} title - Title of the chart.
         * @param {Array} x_axis - Labels for the x-axis.
         * @param {string} y_axis - Label for the y-axis.
         * @param {Array} legend_labels - Labels for the legend.
         * @param {Array} colors - Colors for each series.
         * @param {Object} options - Additional options like alpha values for each series.
         * @returns {Object} - Configuration object for the 2-series bar chart.
         */
        function generateBar2Config(values, title, x_axis, y_axis, legend_labels, colors, options) {
            return {
                type: 'bar',
                title: {
                    text: title,
                    backgroundColor: 'none',
                    fontFamily: "verdana",
                    fontColor: "#7E7E7E",
                    fontSize: "22px",
                    alpha: 1,
                    adjustLayout: true
                },
                plotarea: { margin: 'dynamic' },
                legend: {
                    layout: 'x2',
                    overflow: 'page',
                    alpha: 0.05,
                    shadow: false,
                    align: 'center',
                    adjustLayout: true,
                    marker: { type: 'rectangle', borderColor: 'none', size: 18 },
                    borderWidth: 0,
                    maxItems: 3,
                    toggleAction: 'hide',
                    pageOn: { backgroundColor: '#000', size: 14, alpha: 1 },
                    pageOff: { backgroundColor: '#7E7E7E', size: 14, alpha: 1 },
                    pageStatus: { color: 'black' }
                },
                plot: { 'bars-space-left': 0.15, 'bars-space-right': 0.15 },
                scaleY: {
                    lineColor: '#7E7E7E',
                    item: { fontColor: '#7e7e7e' },
                    guide: { visible: true },
                    label: { text: y_axis, fontFamily: "verdana", bold: true, fontSize: "12px", fontColor: "#7E7E7E" },
                },
                scaleX: {
                    values: x_axis,
                    placement: 'default',
                    tick: { size: 10, placement: 'cross' },
                    itemsOverlap: true,
                    label: { text: "Window Height", fontFamily: "verdana", bold: true, fontSize: "12px", fontColor: "#7E7E7E" },
                },
                series: legend_labels.map((label, i) => ({
                    text: label,
                    values: values[i],
                    backgroundColor: colors[i],
                    alpha: options?.alpha[i] || 1
                }))
            }
        }

        /**
         * Generates configuration for a pie chart.
         * @param {Array} labels - Labels for the pie chart.
         * @param {Array} values - Values for each slice.
         * @param {string} title - Title of the chart.
         * @param {Object} options - Additional options for the pie chart.
         * @returns {Object} - Configuration object for the pie chart.
         */
        function generatePieConfig(labels = pieLabels, values = pieValues, title = 'Screen Width Distribution', options) {
            return {
                type: 'navpie',
                title: { text: title },
                options,
                plot: {
                    borderColor: "#fff",
                    borderWidth: 2,
                    valueBox: [
                        {
                            placement: 'out',
                            text: '%t\n',
                            fontSize: '14',
                            fontFamily: "Open Sans"
                        },
                    ],
                    tooltip: {
                        fontSize: '14',
                        fontFamily: "Open Sans",
                        padding: "5 10",
                        text: "%npv%<br>Count: %v"
                    }
                },
                series: labels.map((label, i) => ({
                    text: label,
                    values: [values[i]]
                }))
            }
        }

        renderCharts();

    </script>
</body>

</html>