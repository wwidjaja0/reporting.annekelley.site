<!doctype html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data Visuals</title>
    <script src="https://cdn.zinggrid.com/zinggrid.min.js" defer></script>
    <script src="https://cdn.zingchart.com/zingchart.min.js" defer></script>
</head>

<body>
    <!-- ZingChart -->
    <style>
        section {
            display: grid;
            grid-template-columns: repeat(auto-fit);
            gap: 1rem;
            padding: 1rem;
        }

        visual-chart {
            background: #eee;
            border-radius: 1rem;
            box-shadow: 0 0.5rem 1rem rgba(0, 0, 0, 0.25);
            padding: 1rem;
        }

        visual-grid {
            background: #eee;
            border-radius: 1rem;
            box-shadow: 0 0.5rem 1rem rgba(0, 0, 0, 0.25);
            padding: 1rem;
        }
    </style>

    <h1><a href="https://annekelley.site/">annekelley.site</a> Dashboard</h1>
    <p>Hint: Try clicking on different things and using your mouse to navigate around the charts!</p>

    <section>
        <h2>Static Data</h2>
        <visual-chart id="userAgent">
            <h3>Most Common Browser Clients - userAgent</h3>
            <p>A <em>word cloud</em> displaying the most frequent browser agent received.</p>
        </visual-chart>
        <visual-chart id="userLang">
            <h3>Most Common Browser Languages - userLang</h3>
            <p>A <em>bar chart</em> displaying the most frequent languages.</p>
        </visual-chart>
        <visual-chart id="acceptsCookies">
            <h3>acceptsCookies</h3>
            <p>A <em>pie chart</em> displaying the % of users that accept cookies.</p>
        </visual-chart>
        <visual-chart id="allowsJavaScript">
            <h3>allowsJavaScript</h3>
            <p>A <em>pie chart</em> displaying the % of users that allow JavaScript.</p>
        </visual-chart>
        <visual-chart id="allowsImages">
            <h3>allowsImages</h3>
            <p>A <em>pie chart</em> displaying the % of users that allow images.</p>
        </visual-chart>
        <visual-chart id="allowsCSS">
            <h3>allowsCSS</h3>
            <p>A <em>pie chart</em> displaying the % of users that allow CSS.</p>
        </visual-chart>
        <visual-chart id="userNetConnType">
            <h3>userNetConnType</h3>
            <p>A <em>bar chart</em> displaying the most frequent network connection.</p>
        </visual-chart>
    </section>
    <section>
        <h2>Performance Data</h2>
        <visual-chart id="pageLoadStart">
            <h3>pageLoadStart</h3>
            <p></p>
        </visual-chart>
        <visual-chart id="pageLoadEnd">
            <h3>pageLoadEnd</h3>
            <p></p>
        </visual-chart>
        <visual-chart id="pageLoadTimeTotal">
            <h3>pageLoadTimeTotal</h3>
            <p></p>
        </visual-chart>
    </section>
    <section>
        <h2>Activity Data</h2>
        <visual-chart id="mouseScatterplot">
            <h3>mouseScatterplot</h3>
            <p></p>
        </visual-chart>
        <visual-chart id="errors">
            <h3>errors</h3>
            <p></p>
        </visual-chart>
    </section>
    <script type="module">
        // Retrieves getData function, which requests columns from a table of the web_analytics DB
        import { getData, userAgentsToWordCloud, countKeyValue, errorsToWordCloud, count } from '/fetch.js';

        ZC.LICENSE = ["569d52cefae586f634c54f86dc99e6a9", "b55b025e438fa8a98e32482b5f768ff5"];

        let userAgentConfig = generateWordCloudConfig(await userAgentsToWordCloud());
        let userLangConfig = generateBarConfig(await countKeyValue('userLang'));
        console.log(await countKeyValue('acceptsCookies'));
        let acceptsCookiesConfig = generateNavPieConfig(await countKeyValue('acceptsCookies'));
        let allowsJavaScriptConfig = generateNavPieConfig(await countKeyValue('allowsJavaScript'));
        let allowsImagesConfig = generateNavPieConfig(await countKeyValue('allowsImages'));
        let allowsCSSConfig = generateNavPieConfig(await countKeyValue('allowsCSS'));
        let userNetConnTypeConfig = generateBarConfig(await countKeyValue('userNetConnType'));

        let pageLoadStartConfig = generateHorizontalBoxPlot(await count('pageLoadStart'));
        let pageLoadEndConfig = generateHorizontalBoxPlot(await count('pageLoadEnd'));
        let pageLoadTimeTotalConfig = generateHorizontalBoxPlot(await count('pageLoadTimeTotal'));

        let errorsConfig = generateWordCloudConfig(await errorsToWordCloud());

        /**
         * Generates configuration for a word cloud chart.
         * @param {string} textData - The aggregated text data for the word cloud.
         * @param {Object} otherOptions - Additional options for the word cloud.
         * @returns {Object} - Configuration object for the word cloud.
         */
        function generateWordCloudConfig(textData = "", otherOptions) {
            return {
                type: 'wordcloud',
                options: {
                    text: textData,
                    aspect: 'flow-center',
                    maxItems: 40,
                    style: {
                        hoverState: {
                            backgroundColor: 'orange',
                            borderRadius: 2,
                            fontColor: 'black'
                        },

                        tooltip: {
                            text: '%text: %hits',
                            visible: true,
                            alpha: 0.8,
                            backgroundColor: 'black',
                            borderRadius: 8,
                            borderColor: 'none',
                            fontColor: 'yellow',
                            fontSize: 14,
                        }
                    }
                },
                otherOptions
            }
        }

        /**
         * Generates configuration for a bar chart.
         * @param {JSON} keyValuePairs - Labels paired with values for the bar chart.
         * @param {Object} otherOptions - Additional options for the bar chart.
         * @returns {Object} - Configuration object for the bar chart.
         */
        function generateBarConfig(keyValuePairs = {}, otherOptions) {
            console.log("Generating bar config with data:", keyValuePairs);
            return {
                type: "bar",
                plot: {
                    showZero: true
                },
                scaleX: {
                    values: Object.keys(keyValuePairs), // x-axis labels
                    item: {
                        angle: -45,
                    },
                    step: 1,
                    'items-overlap': true
                },
                series: [
                    { values: Object.values(keyValuePairs) } // y-axis values
                ]
            };
        }

        /**
         * Generates configuration for a pie chart.
         * @param {Array} keyValuePairs - Labels paired with values for the pie chart.
         * @param {Object} otherOptions - Additional options for the pie chart.
         * @returns {Object} - Configuration object for the pie chart.
         */
        function generateNavPieConfig(keyValuePairs = {}, otherOptions) {
            return {
                type: 'navpie',
                plot: {
                    detach: true,
                    valueBox: {
                        text: '%t\n%npv%'
                    },
                    tooltip: {
                        text: "%npv%<br>Count: %v"
                    },
                },
                series: Object.entries(keyValuePairs).map(([key, value]) => ({
                    text: key,
                    values: [value]
                })),
                otherOptions,
            }
        }

        /**
         * Generates configuration for a horizontal box plot chart.
         * @param {Array} values - Array of numerical values for the box plot.
         * @returns {Object} - Configuration object for the horizontal box plot.
         */
        function generateHorizontalBoxPlot(values, otherOptions) {

            values.sort((a, b) => a - b); // Sort values in ascending order

            const median = values[Math.floor(values.length / 2)];
            const Q1 = values[Math.floor(values.length / 4)];
            const Q3 = values[Math.floor((3 * values.length) / 4)];
            const IQR = Q3 - Q1;
            const lowerFence = Q1 - 1.5 * IQR;
            const upperFence = Q3 + 1.5 * IQR;
            const outliers = values.filter(v => v < lowerFence || v > upperFence);
            const boxPlotValues = [
                Math.max(Math.min(...values.filter(v => v >= lowerFence)), Math.min(...values)), // min (excluding outliers)
                Q1, // lower quartile
                median, // median
                Q3, // upper quartile
                Math.min(Math.max(...values.filter(v => v <= upperFence)), Math.max(...values)) // max (excluding outliers)
            ];

            return {
                graphset: [{
                    type: "hboxplot",
                    plotarea: {
                        margin: 'dynamic'
                    },
                    scaleY: {
                        zooming: true,
                        label: {
                            text: "Milliseconds (ms)"
                        },
                    },
                    tooltip: {
                        visible: true,
                        alpha: 0.8,
                        backgroundColor: 'black',
                        borderRadius: 8,
                        borderColor: 'none',
                        fontColor: 'yellow',
                        fontSize: 14,
                    },
                    options: {
                        box: {
                            "barWidth": 0.1,
                            tooltip: {
                                text: "Observations:<br>Maximum: <strong>%data-max</strong><br>Upper Quartile: <strong>%data-upper-quartile</strong><br>Median: <strong>%data-median</strong><br>Lower Quartile: <strong>%data-lower-quartile</strong><br>Minimum: <strong>%data-min</strong>"
                            }
                        },
                    },
                    outlier: {
                        tooltip: {
                        },
                        marker: {
                            type: 'circle',
                            backgroundColor: '#ff0'
                        }
                    },
                    series: [{
                        dataBox: [boxPlotValues],
                        dataOutlier: [outliers]
                    }],
                    otherOptions
                }]
            };
        }

        try {
            zingchart.render({ id: 'userAgent', data: userAgentConfig, width: '100%' });
            zingchart.render({ id: 'userLang', data: userLangConfig, width: '100%' });
            zingchart.render({ id: 'acceptsCookies', data: acceptsCookiesConfig, width: '100%' });
            zingchart.render({ id: 'allowsJavaScript', data: allowsJavaScriptConfig, width: '100%' });
            zingchart.render({ id: 'allowsImages', data: allowsImagesConfig, width: '100%' });
            zingchart.render({ id: 'allowsCSS', data: allowsCSSConfig, width: '100%' });
            zingchart.render({ id: 'userNetConnType', data: userNetConnTypeConfig, width: '100%' });

            zingchart.render({ id: 'pageLoadStart', data: pageLoadStartConfig, width: '100%' });
            zingchart.render({ id: 'pageLoadEnd', data: pageLoadEndConfig, width: '100%' });
            zingchart.render({ id: 'pageLoadTimeTotal', data: pageLoadTimeTotalConfig, width: '100%' });

            async function renderClickScatterplot() {
                try {
                    const data = await getData('activity', ['eventType', 'clientX', 'clientY']);

                    console.log(data);

                    // keep only click events
                    const clicks = data.filter(item => item.eventType === 'click');

                    console.log(clicks);

                    // transform -> [x, y]
                    const scatterData = clicks.map(item => [
                        parseInt(item.clientX, 10),
                        parseInt(item.clientY, 10)
                    ]);

                    console.log(scatterData);

                    // get max values for scaling
                    const maxX = Math.max(...scatterData.map(d => d[0]).filter(v => !isNaN(v)), 0);
                    const maxY = Math.max(...scatterData.map(d => d[1]).filter(v => !isNaN(v)), 0);

                    const scatterConfig = {
                        type: 'hscatter',
                        backgroundColor: '#fff',
                        plot: {
                            marker: {
                                type: 'circle',
                                size: 4,
                                backgroundColor: '#ff0000'
                            },
                            tooltip: {
                                text: 'Click at (%kvx, %kvy)'
                            }
                        },
                        scaleX: {
                            values: `0:${maxX}:${Math.round(maxX / 10) || 1}`,
                            visible: true
                        },
                        scaleY: {
                            values: `0:${maxY}:${Math.round(maxY / 10) || 1}`,
                            visible: true
                        },
                        series: [
                            {
                                values: scatterData
                            }
                        ]
                    };

                    zingchart.render({
                        id: 'mouseScatterplot',
                        data: scatterConfig,
                        width: 800,
                        height: 600,
                        output: 'canvas'
                    });


                } catch (err) {
                    console.error('Scatterplot failed:', err);
                }
            }

            renderClickScatterplot();

            zingchart.render({ id: 'errors', data: errorsConfig, width: '100%' });
        } catch (e) {
            console.error("Error rendering chart:", e);
        }

    </script>
</body>

</html>