<!doctype html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data Visuals</title>
    <script src="https://cdn.zinggrid.com/zinggrid.min.js" defer></script>
    <script src="https://cdn.zingchart.com/zingchart.min.js" defer></script>
</head>

<body>
    <!-- ZingChart -->
    <style>
        section {
            display: grid;
            grid-template-columns: repeat(auto-fit);
            gap: 1rem;
            padding: 1rem;
        }

        visual-chart {
            background: #eee;
            border-radius: 1rem;
            box-shadow: 0 0.5rem 1rem rgba(0, 0, 0, 0.25);
            padding: 1rem;
        }

        visual-grid {
            background: #eee;
            border-radius: 1rem;
            box-shadow: 0 0.5rem 1rem rgba(0, 0, 0, 0.25);
            padding: 1rem;
        }
    </style>

    <h1><a href="https://annekelley.site/">annekelley.site</a> Dashboard</h1>
    <p>Hint: Try clicking on different things and using your mouse to navigate around the charts!</p>

    <section>
        <h2>Static Data</h2>
        <visual-chart id="userAgent">
            <h3>Most Common Browser Clients - userAgent</h3>
            <p>A <em>word cloud</em> displaying the most frequent browser agent received.</p>
        </visual-chart>
        <visual-chart id="userLang">
            <h3>Most Common Browser Languages - userLang</h3>
            <p>A <em>bar chart</em> displaying the most frequent languages.</p>
        </visual-chart>
        <visual-chart id="acceptsCookies">
            <h3>acceptsCookies</h3>
            <p>A <em>pie chart</em> displaying the % of users that accept cookies.</p>
        </visual-chart>
        <visual-chart id="allowsJavaScript">
            <h3>allowsJavaScript</h3>
            <p>A <em>pie chart</em> displaying the % of users that allow JavaScript.</p>
        </visual-chart>
        <visual-chart id="allowsImages">
            <h3>allowsImages</h3>
            <p>A <em>pie chart</em> displaying the % of users that allow images.</p>
        </visual-chart>
        <visual-chart id="allowsCSS">
            <h3>allowsCSS</h3>
            <p>A <em>pie chart</em> displaying the % of users that allow CSS.</p>
        </visual-chart>
        <visual-chart id="userNetConnType">
            <h3>userNetConnType</h3>
            <p>A <em>bar chart</em> displaying the most frequent network connection.</p>
        </visual-chart>
    </section>
    <section>
        <h2>Performance Data</h2>
        <visual-chart id="pageLoadStart">
            <h3>pageLoadStart</h3>
            <p></p>
        </visual-chart>
        <visual-chart id="pageLoadEnd">
            <h3>pageLoadEnd</h3>
            <p></p>
        </visual-chart>
        <visual-chart id="pageLoadTimeTotal">
            <h3>pageLoadTimeTotal</h3>
            <p></p>
        </visual-chart>
    </section>
    <section>
        <h2>Activity Data</h2>
        <visual-chart id="mouseHeatmap">
            <h3>mouseHeatmap</h3>
            <p></p>
        </visual-chart>
        <visual-chart id="errors">
            <h3>errors</h3>
            <p></p>
        </visual-chart>
    </section>
    <script type="module">
        // Retrieves getData function, which requests columns from a table of the web_analytics DB
        import { getData, userAgentsToWordCloud, countKeyValue, errorsToWordCloud, count } from '/fetch.js';

        ZC.LICENSE = ["569d52cefae586f634c54f86dc99e6a9", "b55b025e438fa8a98e32482b5f768ff5"];

        let userAgentConfig = generateWordCloudConfig(await userAgentsToWordCloud());
        let userLangConfig = generateBarConfig(await countKeyValue('userLang'));
        let acceptsCookiesConfig = generateNavPieConfig(await countKeyValue('acceptsCookies'));
        let allowsJavaScriptConfig = generateNavPieConfig(await countKeyValue('allowsJavaScript'));
        let allowsImagesConfig = generateNavPieConfig(await countKeyValue('allowsImages'));
        let allowsCSSConfig = generateNavPieConfig(await countKeyValue('allowsCSS'));
        let userNetConnTypeConfig = generateBarConfig(await countKeyValue('userNetConnType'));

        let pageLoadStartConfig = generateHorizontalBoxPlot(await count('pageLoadStart'));
        let pageLoadEndConfig = generateHorizontalBoxPlot(await count('pageLoadEnd'));
        let pageLoadTimeTotalConfig = generateHorizontalBoxPlot(await count('pageLoadTimeTotal'));

        let errorsConfig = generateWordCloudConfig(await errorsToWordCloud());

        /**
         * Generates configuration for a word cloud chart.
         * @param {string} textData - The aggregated text data for the word cloud.
         * @param {Object} otherOptions - Additional options for the word cloud.
         * @returns {Object} - Configuration object for the word cloud.
         */
        function generateWordCloudConfig(textData = "", otherOptions) {
            return {
                type: 'wordcloud',
                options: {
                    text: textData,
                    aspect: 'flow-center',
                    maxItems: 40,
                    style: {
                        hoverState: {
                            backgroundColor: 'orange',
                            borderRadius: 2,
                            fontColor: 'black'
                        },

                        tooltip: {
                            text: '%text: %hits',
                            visible: true,
                            alpha: 0.8,
                            backgroundColor: 'black',
                            borderRadius: 8,
                            borderColor: 'none',
                            fontColor: 'yellow',
                            fontSize: 14,
                        }
                    }
                },
                otherOptions
            }
        }

        /**
         * Generates configuration for a bar chart.
         * @param {JSON} keyValuePairs - Labels paired with values for the bar chart.
         * @param {Object} otherOptions - Additional options for the bar chart.
         * @returns {Object} - Configuration object for the bar chart.
         */
        function generateBarConfig(keyValuePairs = {}, otherOptions) {
            console.log("Generating bar config with data:", keyValuePairs);
            return {
                type: "bar",
                plot: {
                    showZero: true
                },
                scaleX: {
                    values: Object.keys(keyValuePairs), // x-axis labels
                    item: {
                        angle: -45,
                    },
                    step: 1,
                    'items-overlap': true
                },
                series: [
                    { values: Object.values(keyValuePairs) } // y-axis values
                ]
            };
        }

        /**
         * Generates configuration for a pie chart.
         * @param {Array} keyValuePairs - Labels paired with values for the pie chart.
         * @param {Object} otherOptions - Additional options for the pie chart.
         * @returns {Object} - Configuration object for the pie chart.
         */
        function generateNavPieConfig(keyValuePairs = {}, otherOptions) {
            return {
                type: 'navpie',
                plot: {
                    detach: true,
                    valueBox: {
                        text: '%t\n%npv%'
                    },
                    tooltip: {
                        text: "%npv%<br>Count: %v"
                    },
                },
                series: Object.entries(keyValuePairs).map(([key, value]) => ({
                    text: key,
                    values: [value]
                })),
                otherOptions,
            }
        }

        /**
         * Generates configuration for a horizontal box plot chart.
         * @param {Array} values - Array of numerical values for the box plot.
         * @returns {Object} - Configuration object for the horizontal box plot.
         */
        function generateHorizontalBoxPlot(values, otherOptions) {

            values.sort((a, b) => a - b); // Sort values in ascending order

            const median = values[Math.floor(values.length / 2)];
            const Q1 = values[Math.floor(values.length / 4)];
            const Q3 = values[Math.floor((3 * values.length) / 4)];
            const IQR = Q3 - Q1;
            const lowerFence = Q1 - 1.5 * IQR;
            const upperFence = Q3 + 1.5 * IQR;
            const outliers = values.filter(v => v < lowerFence || v > upperFence);
            const boxPlotValues = [
                Math.max(Math.min(...values.filter(v => v >= lowerFence)), Math.min(...values)), // min (excluding outliers)
                Q1, // lower quartile
                median, // median
                Q3, // upper quartile
                Math.min(Math.max(...values.filter(v => v <= upperFence)), Math.max(...values)) // max (excluding outliers)
            ];

            return {
                graphset: [{
                    type: "hboxplot",
                    plotarea: {
                        margin: 'dynamic'
                    },
                    scaleY: {
                        zooming: true,
                        label: {
                            text: "Milliseconds (ms)"
                        },
                    },
                    tooltip: {
                        visible: true,
                        alpha: 0.8,
                        backgroundColor: 'black',
                        borderRadius: 8,
                        borderColor: 'none',
                        fontColor: 'yellow',
                        fontSize: 14,
                    },
                    options: {
                        box: {
                            "barWidth": 0.1,
                            tooltip: {
                                text: "Observations:<br>Maximum: <strong>%data-max</strong><br>Upper Quartile: <strong>%data-upper-quartile</strong><br>Median: <strong>%data-median</strong><br>Lower Quartile: <strong>%data-lower-quartile</strong><br>Minimum: <strong>%data-min</strong>"
                            }
                        },
                    },
                    outlier: {
                        tooltip: {
                        },
                        marker: {
                            type: 'circle',
                            backgroundColor: '#ff0'
                        }
                    },
                    series: [{
                        dataBox: [boxPlotValues],
                        dataOutlier: [outliers]
                    }],
                    otherOptions
                }]
            };
        }

        /**
         * Generates configuration for a heat map chart.
         * @param {string} elementID - The ID of the HTML element to bind the heat map to.
         * @returns {Object} - Configuration object for the heat map.
         */
        function generateHeatMap(elementID) {
            var MAX = 100;
            var aData = [];
            zingchart.bind(elementID, 'load', function () {
                var l, k, v;
                var iMaxPoints = 512;
                for (l = 0; l < iMaxPoints; l++) {
                    k = 5 * Math.round(((iMaxPoints - l) % 300) / 5) + 350;
                    v = 5 * Math.round((l % 100) / 5) + 250;
                    aData.push([k, v, MAX]);
                }
                zingchart.exec(elementID, 'heatmap.setdata', {
                    data: aData
                });
            });
        }

        try {
            zingchart.render({ id: 'userAgent', data: userAgentConfig, width: '100%' });
            zingchart.render({ id: 'userLang', data: userLangConfig, width: '100%' });
            zingchart.render({ id: 'acceptsCookies', data: acceptsCookiesConfig, width: '100%' });
            zingchart.render({ id: 'allowsJavaScript', data: allowsJavaScriptConfig, width: '100%' });
            zingchart.render({ id: 'allowsImages', data: allowsImagesConfig, width: '100%' });
            zingchart.render({ id: 'allowsCSS', data: allowsCSSConfig, width: '100%' });
            zingchart.render({ id: 'userNetConnType', data: userNetConnTypeConfig, width: '100%' });

            zingchart.render({ id: 'pageLoadStart', data: pageLoadStartConfig, width: '100%' });
            zingchart.render({ id: 'pageLoadEnd', data: pageLoadEndConfig, width: '100%' });
            zingchart.render({ id: 'pageLoadTimeTotal', data: pageLoadTimeTotalConfig, width: '100%' });

            async function renderClickHeatmap() {
                try {
                    // Get your activity logs with coordinates
                    const data = await getData('activity', ['message', 'mouseX', 'mouseY']);

                    // Filter only click events
                    const clicks = data.filter(item => item.message === 'click');

                    // Transform into [x, y, weight] format for ZingChart heatmap
                    // Here each click has weight 1
                    const heatmapData = clicks.map(item => [
                        parseInt(item.mouseX, 10),
                        parseInt(item.mouseY, 10),
                        1
                    ]);

                    // Find maximum intensity (just number of clicks at the same spot)
                    const maxValue = 1; // since each click counts as 1, ZingChart handles scaling

                    // Create chart config
                    const chartConfig = {
                        type: 'null',
                        backgroundColor: '#fff',
                        flat: true,
                        heatmap: {
                            tooltip: {
                                text: '%value clicks',
                                decimals: 0
                            },
                            alpha: 1,
                            sortData: true,
                            brushType: 'square',
                            size: 10,
                            blur: 6,
                        },
                        colorScale: {
                            aspect: 'gradient',
                            gradientStops: '0.0 0.4 0.6 0.7 0.8 1.0',
                            gradientColors: 'rgba(0,0,255,0) #0000ff #00ffff #bfff00 #ffff00 #ff0000',
                            backgroundColor: null,
                            alpha: 0.8,
                        },
                        shapes: [
                            {
                                type: 'zingchart.rect',
                                id: 'heatmapContainer',
                                x: 0,
                                y: 0,
                                width: '100%',
                                height: '100%'
                            }
                        ]
                    };

                    // Render chart
                    zingchart.render({
                        id: 'mouseHeatmap',
                        width: '800px',
                        height: '600px',
                        output: 'canvas',
                        data: chartConfig,
                        modules: 'heatmap,color-scale'
                    });

                    // Inject heatmap data after render
                    zingchart.bind('mouseHeatmap', 'load', function () {
                        zingchart.exec('mouseHeatmap', 'colorscale.update', {
                            data: { maxValue }
                        });

                        zingchart.exec('mouseHeatmap', 'heatmap.setdata', {
                            minValue: 0,
                            maxValue,
                            data: heatmapData,
                            size: 12,
                            blur: 6,
                        });
                    });

                } catch (err) {
                    console.error("Failed to render heatmap:", err);
                }
            }

            // Run it
            renderClickHeatmap();


            zingchart.render({ id: 'errors', data: errorsConfig, width: '100%' });
        } catch (e) {
            console.error("Error rendering chart:", e);
        }

    </script>
</body>

</html>